// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.dynatrace.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ProcessGroupDetectionFlagsState extends com.pulumi.resources.ResourceArgs {

    public static final ProcessGroupDetectionFlagsState Empty = new ProcessGroupDetectionFlagsState();

    /**
     * In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
     * 
     */
    @Import(name="addNodeJsScriptName")
    private @Nullable Output<Boolean> addNodeJsScriptName;

    /**
     * @return In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
     * 
     */
    public Optional<Output<Boolean>> addNodeJsScriptName() {
        return Optional.ofNullable(this.addNodeJsScriptName);
    }

    /**
     * Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
     * 
     */
    @Import(name="autoDetectCassandraClusters")
    private @Nullable Output<Boolean> autoDetectCassandraClusters;

    /**
     * @return Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
     * 
     */
    public Optional<Output<Boolean>> autoDetectCassandraClusters() {
        return Optional.ofNullable(this.autoDetectCassandraClusters);
    }

    /**
     * Enabling this flag will detect Spring Boot process groups based on command line and applications&#39; configuration files.
     * 
     */
    @Import(name="autoDetectSpringBoot")
    private @Nullable Output<Boolean> autoDetectSpringBoot;

    /**
     * @return Enabling this flag will detect Spring Boot process groups based on command line and applications&#39; configuration files.
     * 
     */
    public Optional<Output<Boolean>> autoDetectSpringBoot() {
        return Optional.ofNullable(this.autoDetectSpringBoot);
    }

    /**
     * Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
     * 
     */
    @Import(name="autoDetectTibcoContainerEditionEngines")
    private @Nullable Output<Boolean> autoDetectTibcoContainerEditionEngines;

    /**
     * @return Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
     * 
     */
    public Optional<Output<Boolean>> autoDetectTibcoContainerEditionEngines() {
        return Optional.ofNullable(this.autoDetectTibcoContainerEditionEngines);
    }

    /**
     * Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
     * 
     */
    @Import(name="autoDetectTibcoEngines")
    private @Nullable Output<Boolean> autoDetectTibcoEngines;

    /**
     * @return Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
     * 
     */
    public Optional<Output<Boolean>> autoDetectTibcoEngines() {
        return Optional.ofNullable(this.autoDetectTibcoEngines);
    }

    /**
     * Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
     * 
     */
    @Import(name="autoDetectWebMethodsIntegrationServer")
    private @Nullable Output<Boolean> autoDetectWebMethodsIntegrationServer;

    /**
     * @return Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
     * 
     */
    public Optional<Output<Boolean>> autoDetectWebMethodsIntegrationServer() {
        return Optional.ofNullable(this.autoDetectWebMethodsIntegrationServer);
    }

    /**
     * Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
     * 
     */
    @Import(name="autoDetectWebSphereLibertyApplication")
    private @Nullable Output<Boolean> autoDetectWebSphereLibertyApplication;

    /**
     * @return Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
     * 
     */
    public Optional<Output<Boolean>> autoDetectWebSphereLibertyApplication() {
        return Optional.ofNullable(this.autoDetectWebSphereLibertyApplication);
    }

    /**
     * Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
     * 
     */
    @Import(name="groupIbmmqbyInstanceName")
    private @Nullable Output<Boolean> groupIbmmqbyInstanceName;

    /**
     * @return Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
     * 
     */
    public Optional<Output<Boolean>> groupIbmmqbyInstanceName() {
        return Optional.ofNullable(this.groupIbmmqbyInstanceName);
    }

    /**
     * Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
     * 
     */
    @Import(name="identifyJbossServerBySystemProperty")
    private @Nullable Output<Boolean> identifyJbossServerBySystemProperty;

    /**
     * @return Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
     * 
     */
    public Optional<Output<Boolean>> identifyJbossServerBySystemProperty() {
        return Optional.ofNullable(this.identifyJbossServerBySystemProperty);
    }

    /**
     * To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don&#39;t result in Dynatrace registering pre-existing processes as new processes.
     * 
     */
    @Import(name="ignoreUniqueIdentifiers")
    private @Nullable Output<Boolean> ignoreUniqueIdentifiers;

    /**
     * @return To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don&#39;t result in Dynatrace registering pre-existing processes as new processes.
     * 
     */
    public Optional<Output<Boolean>> ignoreUniqueIdentifiers() {
        return Optional.ofNullable(this.ignoreUniqueIdentifiers);
    }

    /**
     * The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
     * 
     */
    @Import(name="scope")
    private @Nullable Output<String> scope;

    /**
     * @return The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
     * 
     */
    public Optional<Output<String>> scope() {
        return Optional.ofNullable(this.scope);
    }

    /**
     * Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
     * 
     */
    @Import(name="shortLivedProcessesMonitoring")
    private @Nullable Output<Boolean> shortLivedProcessesMonitoring;

    /**
     * @return Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
     * 
     */
    public Optional<Output<Boolean>> shortLivedProcessesMonitoring() {
        return Optional.ofNullable(this.shortLivedProcessesMonitoring);
    }

    /**
     * Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
     * 
     */
    @Import(name="splitOracleDatabasePg")
    private @Nullable Output<Boolean> splitOracleDatabasePg;

    /**
     * @return Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
     * 
     */
    public Optional<Output<Boolean>> splitOracleDatabasePg() {
        return Optional.ofNullable(this.splitOracleDatabasePg);
    }

    /**
     * Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
     * 
     */
    @Import(name="splitOracleListenerPg")
    private @Nullable Output<Boolean> splitOracleListenerPg;

    /**
     * @return Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
     * 
     */
    public Optional<Output<Boolean>> splitOracleListenerPg() {
        return Optional.ofNullable(this.splitOracleListenerPg);
    }

    /**
     * By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can&#39;t have multiple nodes on a single host.
     * 
     */
    @Import(name="useCatalinaBase")
    private @Nullable Output<Boolean> useCatalinaBase;

    /**
     * @return By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can&#39;t have multiple nodes on a single host.
     * 
     */
    public Optional<Output<Boolean>> useCatalinaBase() {
        return Optional.ofNullable(this.useCatalinaBase);
    }

    /**
     * By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can&#39;t serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
     * 
     */
    @Import(name="useDockerContainerName")
    private @Nullable Output<Boolean> useDockerContainerName;

    /**
     * @return By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can&#39;t serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
     * 
     */
    public Optional<Output<Boolean>> useDockerContainerName() {
        return Optional.ofNullable(this.useDockerContainerName);
    }

    private ProcessGroupDetectionFlagsState() {}

    private ProcessGroupDetectionFlagsState(ProcessGroupDetectionFlagsState $) {
        this.addNodeJsScriptName = $.addNodeJsScriptName;
        this.autoDetectCassandraClusters = $.autoDetectCassandraClusters;
        this.autoDetectSpringBoot = $.autoDetectSpringBoot;
        this.autoDetectTibcoContainerEditionEngines = $.autoDetectTibcoContainerEditionEngines;
        this.autoDetectTibcoEngines = $.autoDetectTibcoEngines;
        this.autoDetectWebMethodsIntegrationServer = $.autoDetectWebMethodsIntegrationServer;
        this.autoDetectWebSphereLibertyApplication = $.autoDetectWebSphereLibertyApplication;
        this.groupIbmmqbyInstanceName = $.groupIbmmqbyInstanceName;
        this.identifyJbossServerBySystemProperty = $.identifyJbossServerBySystemProperty;
        this.ignoreUniqueIdentifiers = $.ignoreUniqueIdentifiers;
        this.scope = $.scope;
        this.shortLivedProcessesMonitoring = $.shortLivedProcessesMonitoring;
        this.splitOracleDatabasePg = $.splitOracleDatabasePg;
        this.splitOracleListenerPg = $.splitOracleListenerPg;
        this.useCatalinaBase = $.useCatalinaBase;
        this.useDockerContainerName = $.useDockerContainerName;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ProcessGroupDetectionFlagsState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ProcessGroupDetectionFlagsState $;

        public Builder() {
            $ = new ProcessGroupDetectionFlagsState();
        }

        public Builder(ProcessGroupDetectionFlagsState defaults) {
            $ = new ProcessGroupDetectionFlagsState(Objects.requireNonNull(defaults));
        }

        /**
         * @param addNodeJsScriptName In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
         * 
         * @return builder
         * 
         */
        public Builder addNodeJsScriptName(@Nullable Output<Boolean> addNodeJsScriptName) {
            $.addNodeJsScriptName = addNodeJsScriptName;
            return this;
        }

        /**
         * @param addNodeJsScriptName In older versions, Node.js applications were distinguished based on their directory name, omitting the script name. Changing this setting may change the general handling of Node.js process groups. Leave unchanged if in doubt.
         * 
         * @return builder
         * 
         */
        public Builder addNodeJsScriptName(Boolean addNodeJsScriptName) {
            return addNodeJsScriptName(Output.of(addNodeJsScriptName));
        }

        /**
         * @param autoDetectCassandraClusters Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectCassandraClusters(@Nullable Output<Boolean> autoDetectCassandraClusters) {
            $.autoDetectCassandraClusters = autoDetectCassandraClusters;
            return this;
        }

        /**
         * @param autoDetectCassandraClusters Enabling this flag will detect separate Cassandra process groups based on the configured Cassandra cluster name.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectCassandraClusters(Boolean autoDetectCassandraClusters) {
            return autoDetectCassandraClusters(Output.of(autoDetectCassandraClusters));
        }

        /**
         * @param autoDetectSpringBoot Enabling this flag will detect Spring Boot process groups based on command line and applications&#39; configuration files.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectSpringBoot(@Nullable Output<Boolean> autoDetectSpringBoot) {
            $.autoDetectSpringBoot = autoDetectSpringBoot;
            return this;
        }

        /**
         * @param autoDetectSpringBoot Enabling this flag will detect Spring Boot process groups based on command line and applications&#39; configuration files.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectSpringBoot(Boolean autoDetectSpringBoot) {
            return autoDetectSpringBoot(Output.of(autoDetectSpringBoot));
        }

        /**
         * @param autoDetectTibcoContainerEditionEngines Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectTibcoContainerEditionEngines(@Nullable Output<Boolean> autoDetectTibcoContainerEditionEngines) {
            $.autoDetectTibcoContainerEditionEngines = autoDetectTibcoContainerEditionEngines;
            return this;
        }

        /**
         * @param autoDetectTibcoContainerEditionEngines Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectTibcoContainerEditionEngines(Boolean autoDetectTibcoContainerEditionEngines) {
            return autoDetectTibcoContainerEditionEngines(Output.of(autoDetectTibcoContainerEditionEngines));
        }

        /**
         * @param autoDetectTibcoEngines Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectTibcoEngines(@Nullable Output<Boolean> autoDetectTibcoEngines) {
            $.autoDetectTibcoEngines = autoDetectTibcoEngines;
            return this;
        }

        /**
         * @param autoDetectTibcoEngines Enabling this flag will detect separate TIBCO BusinessWorks process groups per engine property file.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectTibcoEngines(Boolean autoDetectTibcoEngines) {
            return autoDetectTibcoEngines(Output.of(autoDetectTibcoEngines));
        }

        /**
         * @param autoDetectWebMethodsIntegrationServer Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectWebMethodsIntegrationServer(@Nullable Output<Boolean> autoDetectWebMethodsIntegrationServer) {
            $.autoDetectWebMethodsIntegrationServer = autoDetectWebMethodsIntegrationServer;
            return this;
        }

        /**
         * @param autoDetectWebMethodsIntegrationServer Enabling this flag will detect webMethods Integration Server including specific properties like install root and product name.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectWebMethodsIntegrationServer(Boolean autoDetectWebMethodsIntegrationServer) {
            return autoDetectWebMethodsIntegrationServer(Output.of(autoDetectWebMethodsIntegrationServer));
        }

        /**
         * @param autoDetectWebSphereLibertyApplication Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectWebSphereLibertyApplication(@Nullable Output<Boolean> autoDetectWebSphereLibertyApplication) {
            $.autoDetectWebSphereLibertyApplication = autoDetectWebSphereLibertyApplication;
            return this;
        }

        /**
         * @param autoDetectWebSphereLibertyApplication Enabling this flag will detect separate WebSphere Liberty process groups based on java command line.
         * 
         * @return builder
         * 
         */
        public Builder autoDetectWebSphereLibertyApplication(Boolean autoDetectWebSphereLibertyApplication) {
            return autoDetectWebSphereLibertyApplication(Output.of(autoDetectWebSphereLibertyApplication));
        }

        /**
         * @param groupIbmmqbyInstanceName Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
         * 
         * @return builder
         * 
         */
        public Builder groupIbmmqbyInstanceName(@Nullable Output<Boolean> groupIbmmqbyInstanceName) {
            $.groupIbmmqbyInstanceName = groupIbmmqbyInstanceName;
            return this;
        }

        /**
         * @param groupIbmmqbyInstanceName Enable to group and separately analyze the processes of each IBM MQ Queue manager instance. Each process group receives a unique name based on the queue manager instance name.
         * 
         * @return builder
         * 
         */
        public Builder groupIbmmqbyInstanceName(Boolean groupIbmmqbyInstanceName) {
            return groupIbmmqbyInstanceName(Output.of(groupIbmmqbyInstanceName));
        }

        /**
         * @param identifyJbossServerBySystemProperty Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
         * 
         * @return builder
         * 
         */
        public Builder identifyJbossServerBySystemProperty(@Nullable Output<Boolean> identifyJbossServerBySystemProperty) {
            $.identifyJbossServerBySystemProperty = identifyJbossServerBySystemProperty;
            return this;
        }

        /**
         * @param identifyJbossServerBySystemProperty Enabling this flag will detect the JBoss server name from the system property jboss.server.name=\n\n, only if -D[Server:\n\n] is not set.
         * 
         * @return builder
         * 
         */
        public Builder identifyJbossServerBySystemProperty(Boolean identifyJbossServerBySystemProperty) {
            return identifyJbossServerBySystemProperty(Output.of(identifyJbossServerBySystemProperty));
        }

        /**
         * @param ignoreUniqueIdentifiers To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don&#39;t result in Dynatrace registering pre-existing processes as new processes.
         * 
         * @return builder
         * 
         */
        public Builder ignoreUniqueIdentifiers(@Nullable Output<Boolean> ignoreUniqueIdentifiers) {
            $.ignoreUniqueIdentifiers = ignoreUniqueIdentifiers;
            return this;
        }

        /**
         * @param ignoreUniqueIdentifiers To determine the unique identity of each detected process, and to generate a unique name for each detected process, Dynatrace evaluates the name of the directory that each process binary is contained within. For application containers like Tomcat and JBoss, Dynatrace evaluates important directories like CATALINA*HOME and JBOSS*HOME for this information. In some automated deployment scenarios such directory names are updated automatically with new version numbers, build numbers, dates, or GUIDs. Enable this setting to ensure that automated directory name changes don&#39;t result in Dynatrace registering pre-existing processes as new processes.
         * 
         * @return builder
         * 
         */
        public Builder ignoreUniqueIdentifiers(Boolean ignoreUniqueIdentifiers) {
            return ignoreUniqueIdentifiers(Output.of(ignoreUniqueIdentifiers));
        }

        /**
         * @param scope The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
         * 
         * @return builder
         * 
         */
        public Builder scope(@Nullable Output<String> scope) {
            $.scope = scope;
            return this;
        }

        /**
         * @param scope The scope of this setting (HOST, HOST_GROUP). Omit this property if you want to cover the whole environment.
         * 
         * @return builder
         * 
         */
        public Builder scope(String scope) {
            return scope(Output.of(scope));
        }

        /**
         * @param shortLivedProcessesMonitoring Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
         * 
         * @return builder
         * 
         */
        public Builder shortLivedProcessesMonitoring(@Nullable Output<Boolean> shortLivedProcessesMonitoring) {
            $.shortLivedProcessesMonitoring = shortLivedProcessesMonitoring;
            return this;
        }

        /**
         * @param shortLivedProcessesMonitoring Enable to monitor CPU and memory usage of short lived processes, otherwise being lost by traditional monitoring. Disabling this flag blocks passing data to cluster only, it does not stop data collection and has no effect on performance.
         * 
         * @return builder
         * 
         */
        public Builder shortLivedProcessesMonitoring(Boolean shortLivedProcessesMonitoring) {
            return shortLivedProcessesMonitoring(Output.of(shortLivedProcessesMonitoring));
        }

        /**
         * @param splitOracleDatabasePg Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
         * 
         * @return builder
         * 
         */
        public Builder splitOracleDatabasePg(@Nullable Output<Boolean> splitOracleDatabasePg) {
            $.splitOracleDatabasePg = splitOracleDatabasePg;
            return this;
        }

        /**
         * @param splitOracleDatabasePg Enable to group and separately analyze the processes of each Oracle DB. Each process group receives a unique name based on the Oracle DB SID.
         * 
         * @return builder
         * 
         */
        public Builder splitOracleDatabasePg(Boolean splitOracleDatabasePg) {
            return splitOracleDatabasePg(Output.of(splitOracleDatabasePg));
        }

        /**
         * @param splitOracleListenerPg Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
         * 
         * @return builder
         * 
         */
        public Builder splitOracleListenerPg(@Nullable Output<Boolean> splitOracleListenerPg) {
            $.splitOracleListenerPg = splitOracleListenerPg;
            return this;
        }

        /**
         * @param splitOracleListenerPg Enable to group and separately analyze the processes of each Oracle Listener. Each process group receives a unique name based on the Oracle Listener name.
         * 
         * @return builder
         * 
         */
        public Builder splitOracleListenerPg(Boolean splitOracleListenerPg) {
            return splitOracleListenerPg(Output.of(splitOracleListenerPg));
        }

        /**
         * @param useCatalinaBase By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can&#39;t have multiple nodes on a single host.
         * 
         * @return builder
         * 
         */
        public Builder useCatalinaBase(@Nullable Output<Boolean> useCatalinaBase) {
            $.useCatalinaBase = useCatalinaBase;
            return this;
        }

        /**
         * @param useCatalinaBase By default, Tomcat clusters are identified and named based on the CATALINA*HOME directory name. This setting results in the use of the CATALINA*BASE directory name to identify multiple Tomcat nodes within each Tomcat cluster. If this setting is not enabled, each CATALINA*HOME+CATALINA*BASE combination will be considered a separate Tomcat cluster. In other words, Tomcat clusters can&#39;t have multiple nodes on a single host.
         * 
         * @return builder
         * 
         */
        public Builder useCatalinaBase(Boolean useCatalinaBase) {
            return useCatalinaBase(Output.of(useCatalinaBase));
        }

        /**
         * @param useDockerContainerName By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can&#39;t serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
         * 
         * @return builder
         * 
         */
        public Builder useDockerContainerName(@Nullable Output<Boolean> useDockerContainerName) {
            $.useDockerContainerName = useDockerContainerName;
            return this;
        }

        /**
         * @param useDockerContainerName By default, Dynatrace uses image names as identifiers for individual process groups, with one process-group instance per host. Normally Docker container names can&#39;t serve as stable identifiers of process group instances because they are variable and auto-generated. You can however manually assign proper container names to their Docker instances. Such manually-assigned container names can serve as reliable process-group instance identifiers. This flag instructs Dynatrace to use Docker-provided names to distinguish between multiple instances of the same image. If this flag is not applied and you run multiple containers of the same image on the same host, the resulting processes will be consolidated into a single process view. Use this flag with caution!
         * 
         * @return builder
         * 
         */
        public Builder useDockerContainerName(Boolean useDockerContainerName) {
            return useDockerContainerName(Output.of(useDockerContainerName));
        }

        public ProcessGroupDetectionFlagsState build() {
            return $;
        }
    }

}
